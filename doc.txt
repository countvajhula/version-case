_version-case_ : conditionally compile code based on current version number.

Danny Yoo (dyoo@hkn.eecs.berkeley.edu / dyoo@wpi.edu)                
                

Example
=======

(module some-sample-unit-code mzscheme
  (require (planet "version-case.ss" ("dyoo" "version-case.plt" 1 0))
           (lib "mred.ss" "mred"))
  
  ;; Small test code to see that we can write unit-dependent code
  ;; that still runs under both 360 and 369.
  
  (version-case
   [(version<= (version) "360")
    (printf "old unit code~n")
    (require (lib "tool.ss" "drscheme")
             (lib "unitsig.ss"))
    
    (define tool@
      (unit/sig drscheme:tool-exports^
        (import drscheme:tool^)
        (define (phase1)
          (message-box "phase1"))
        (define (phase2)
          (message-box "phase2"))))]
   
   [else
    (printf "new unit code~n")
    (require (lib "tool.ss" "drscheme")
             (lib "unit.ss"))
    (define-unit tool@
      (import drscheme:tool^)
      (export drscheme:tool-exports^)
      (define (phase1)
        (message-box "phase1"))
      (define (phase2)
        (message-box "phase2")))]))

                
Usage
=====

_version-case_ : SYNTAX

    (version-case [test code ...]
                  ... 
                  [else code ...])

Expands out to one of the CODE blocks, depending on which test succeeds first.
The test expression has access to the mzscheme primitives.  In addition,
one other function, VERSION<=, is made available for convenience.

    ;; version<=: string string -> boolean
    ;; Returns true if the strings, treated as version strings "major.minor",
    ;; compare as <=.


Bugs / Gotchas
==============

The tests are done at compile time, in the standard mzscheme environment built with
(make-namespace).  Also, if the test itself raises exceptions, the error messages
aren't that good.
